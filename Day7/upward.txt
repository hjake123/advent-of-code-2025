// My initial solution for Part 2, now unused after I realized I didn't need to count upward (not sure why I thought of doing it this way...?)
// Count upward by recursively checking different paths that could happen upward.
// If you reach the S, return 1. If you leave the grid, return 0.
// Otherwise, return the sum of the possible paths above yourself.

static long CountTimelinesUpward(List<string> grid, int x_positon, int row_number, ref Dictionary<Tuple<int, int>, long> memos)
{
    var memo_key = Tuple.Create(x_positon, row_number);
    if (memos.ContainsKey(memo_key))
    {
        return memos[memo_key];
    }

    if (row_number <= 0)
    {
        memos.Add(memo_key, grid[row_number][x_positon] == 'S' ? 1 : 0);
        return grid[row_number][x_positon] == 'S' ? 1 : 0;
    }
    if (grid[row_number][x_positon] == '^')
    {
        // No valid path ever terminates in a splitter.
        memos.Add(memo_key, 0);
        return 0;
    }
    long tally = 0;
    if (x_positon > 0 && grid[row_number][x_positon - 1] == '^')
    {
        // There is a splitter to our left, so there could be a path to the left of us.
        tally += CountTimelinesUpward(grid, x_positon - 1, row_number - 1, ref memos);
    }
    if (x_positon < grid[row_number].Length-1 && grid[row_number][x_positon + 1] == '^')
    {
        // There is a splitter to our right, so there could be a path to the right of us.
        tally += CountTimelinesUpward(grid, x_positon + 1, row_number - 1, ref memos);
    }
    tally += CountTimelinesUpward(grid, x_positon, row_number - 1, ref memos);
    memos.Add(memo_key, tally);
    return tally;
}